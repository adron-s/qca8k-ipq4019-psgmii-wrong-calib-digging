diff -rNu a/drivers/net/dsa/qca/qca8k-ipq4019.c b/drivers/net/dsa/qca/qca8k-ipq4019.c
--- a/drivers/net/dsa/qca/qca8k-ipq4019.c	2022-04-11 11:01:21.796045947 +0300
+++ b/drivers/net/dsa/qca/qca8k-ipq4019.c	2022-04-14 10:52:55.976137908 +0300
@@ -612,69 +612,322 @@
 	return 0;
 }
 
-static int psgmii_vco_calibrate(struct dsa_switch *ds)
+static void ipq_psgmii_do_reset(struct qca8k_priv *priv, int how)
+{
+	struct reset_control *rst;
+	const char rst_name[ ] = "psgmii_rst";
+	rst = devm_reset_control_get(priv->dev, rst_name);
+	if (IS_ERR(rst)) {
+		dev_err(priv->dev, "Failed to get %s control!\n", rst_name);
+		return;
+	}
+
+	if (how == 0 || how >= 10) {
+		reset_control_assert(rst);
+	}
+	if (how >= 10) {
+		set_current_state(TASK_INTERRUPTIBLE);
+		schedule_timeout(msecs_to_jiffies(100 * how));
+	}
+	if (how == 1 || how >= 10) {
+		reset_control_deassert(rst);
+	}
+
+	reset_control_put(rst);
+}
+
+
+static int psgmii_vco_calibrate(struct qca8k_priv *priv, int post_reset_delay)
 {
-	struct qca8k_priv *priv = ds->priv;
 	int val, ret;
 
 	if (!priv->psgmii_ethphy) {
-		dev_err(ds->dev, "PSGMII eth PHY missing, calibration failed!\n");
+		dev_err(priv->dev, "PSGMII eth PHY missing, calibration failed!\n");
 		return -ENODEV;
 	}
 
 	/* Fix PSGMII RX 20bit */
 	ret = phy_write(priv->psgmii_ethphy, MII_BMCR, 0x5b);
-	/* Reset PSGMII PHY */
+	/* Freeze PSGMII RX CDR */
+	ret = phy_write(priv->psgmii_ethphy, MII_RESV2, 0x2230);
+
+	/* Reset PHY PSGMII */
 	ret = phy_write(priv->psgmii_ethphy, MII_BMCR, 0x1b);
-	/* Release reset */
-	ret = phy_write(priv->psgmii_ethphy, MII_BMCR, 0x5b);
+	/* Reset IPQ-40XX PSGMII */
+	ipq_psgmii_do_reset(priv, 0);
 
-	/* Poll for VCO PLL calibration finish */
-	ret = phy_read_mmd_poll_timeout(priv->psgmii_ethphy,
-					MDIO_MMD_PMAPMD,
-					0x28, val,
-					(val & BIT(0)),
-					10000, 1000000,
-					false);
-	if (ret) {
-		dev_err(ds->dev, "QCA807x PSGMII VCO calibration PLL not ready\n");
-		return ret;
+	if (post_reset_delay > 0) {
+		set_current_state(TASK_INTERRUPTIBLE);
+		schedule_timeout(msecs_to_jiffies(post_reset_delay));
 	}
 
-	/* Freeze PSGMII RX CDR */
-	ret = phy_write(priv->psgmii_ethphy, MII_RESV2, 0x2230);
+	/* Release IPQ-40XX PSGMII reset */
+	ipq_psgmii_do_reset(priv, 1);
 
 	/* Start PSGMIIPHY VCO PLL calibration */
-	ret = regmap_set_bits(priv->psgmii,
+	/* ret = regmap_set_bits(priv->psgmii,
 			PSGMIIPHY_VCO_CALIBRATION_CONTROL_REGISTER_1,
-			PSGMIIPHY_REG_PLL_VCO_CALIB_RESTART);
+			PSGMIIPHY_REG_PLL_VCO_CALIB_RESTART); */
 
-	/* Poll for PSGMIIPHY PLL calibration finish */
+	/* Poll for PSGMIIPHY PLL calibration finish - Dakota(IPQ40xx) */
 	ret = regmap_read_poll_timeout(priv->psgmii,
 				       PSGMIIPHY_VCO_CALIBRATION_CONTROL_REGISTER_2,
 				       val, val & PSGMIIPHY_REG_PLL_VCO_CALIB_READY,
 				       10000, 1000000);
 	if (ret) {
-		dev_err(ds->dev, "PSGMIIPHY VCO calibration PLL not ready\n");
+		dev_err(priv->dev, "IPQ PSGMIIPHY VCO calibration PLL not ready\n");
+		return ret;
+	}
+
+	/* Release PHY PSGMII reset */
+	ret = phy_write(priv->psgmii_ethphy, MII_BMCR, 0x5b);
+	/* Poll for VCO PLL calibration finish - Malibu(QCA8075) */
+	ret = phy_read_mmd_poll_timeout(priv->psgmii_ethphy,
+					MDIO_MMD_PMAPMD,
+					0x28, val,
+					(val & BIT(0)),
+					10000, 1000000,
+					false);
+	if (ret) {
+		dev_err(priv->dev, "QCA807x PSGMII VCO calibration PLL not ready\n");
 		return ret;
 	}
 
 	/* Release PSGMII RX CDR */
 	ret = phy_write(priv->psgmii_ethphy, MII_RESV2, 0x3230);
-
 	/* Release PSGMII RX 20bit */
 	ret = phy_write(priv->psgmii_ethphy, MII_BMCR, 0x5f);
 
 	return ret;
 }
 
+static void qca8k_switch_port_loopback_on_off(
+struct qca8k_priv *priv, int port, int on)
+{
+	u32 val = QCA8K_PORT_LOOKUP_LOOPBACK;
+
+	if (on == 0)
+		val = 0;
+
+	qca8k_rmw(priv, QCA8K_PORT_LOOKUP_CTRL(port),
+		QCA8K_PORT_LOOKUP_LOOPBACK,	val);
+}
+
+static int qca8k_wait_for_phy_link_state(
+struct phy_device *phy, int need_status)
+{
+	int a;
+	u16 status;
+
+	for (a = 0; a < 100; a++) {
+		status = phy_read(phy, MII_QCA8075_SSTATUS);
+		status &= QCA8075_PHY_SPEC_STATUS_LINK;
+		status = !!status;
+		if (status == need_status) {
+			return 0;
+		}
+		mdelay(8);
+	}
+
+	return -1;
+}
+
+static void qca8k_phy_loopback_on_off(struct qca8k_priv *priv,
+struct phy_device *phy, int sw_port, int on)
+{
+	if (on) {
+		phy_write(phy, MII_BMCR, BMCR_ANENABLE | BMCR_RESET);
+		phy_modify(phy, MII_BMCR, BMCR_PDOWN, BMCR_PDOWN);
+		qca8k_wait_for_phy_link_state(phy, 0);
+		qca8k_write(priv, QCA8K_REG_PORT_STATUS(sw_port), 0);
+		phy_write(phy, MII_BMCR,
+			BMCR_SPEED1000 |
+			BMCR_FULLDPLX |
+			BMCR_LOOPBACK);
+		qca8k_wait_for_phy_link_state(phy, 1);
+		qca8k_write(priv, QCA8K_REG_PORT_STATUS(sw_port),
+			QCA8K_PORT_STATUS_SPEED_1000 |
+			QCA8K_PORT_STATUS_TXMAC |
+			QCA8K_PORT_STATUS_RXMAC |
+			QCA8K_PORT_STATUS_DUPLEX);
+		qca8k_rmw(priv, QCA8K_PORT_LOOKUP_CTRL(sw_port),
+			QCA8K_PORT_LOOKUP_STATE_FORWARD,
+			QCA8K_PORT_LOOKUP_STATE_FORWARD);
+	} else { /* off */
+		qca8k_write(priv, QCA8K_REG_PORT_STATUS(sw_port), 0);
+		qca8k_rmw(priv, QCA8K_PORT_LOOKUP_CTRL(sw_port),
+			QCA8K_PORT_LOOKUP_STATE_DISABLED,
+			QCA8K_PORT_LOOKUP_STATE_DISABLED);
+		phy_write(phy, MII_BMCR, BMCR_SPEED1000 | BMCR_ANENABLE | BMCR_RESET);
+	}
+}
+
+static void qca8k_phy_pkt_gen_on_off(struct qca8k_priv *priv,
+struct phy_device *phy, int pkts_num, int on)
+{
+	if (on) {
+		int val;
+		/* Enable CRC checker and packets counters */
+		phy_write_mmd(phy, 7, QCA8075_MMD7_CRC_AND_PKTS_COUNT,
+			0x0000);
+		phy_write_mmd(phy, 7, QCA8075_MMD7_CRC_AND_PKTS_COUNT,
+			QCA8075_MMD7_CNT_FRAME_CHK_EN | QCA8075_MMD7_CNT_SELFCLR);
+		qca8k_wait_for_phy_link_state(phy, 1);
+		/* packet number */
+		phy_write_mmd(phy, 7, QCA8075_MMD7_PKT_GEN_PKT_NUMB, pkts_num);
+		/* pkt size - 1504 bytes + 20 bytes */
+		phy_write_mmd(phy, 7, QCA8075_MMD7_PKT_GEN_PKT_SIZE, 1504);
+		/* start traffic gen */
+		phy_write_mmd(phy, 7, QCA8075_MMD7_PKT_GEN_CTRL,
+			QCA8075_MMD7_PKT_GEN_START | QCA8075_MMD7_PKT_GEN_INPROGR);
+		/* wait for all traffic end: 4096(pkt num)*1524(size)*8ns(125MHz)=49938us */
+		phy_read_mmd_poll_timeout(phy, 7,	QCA8075_MMD7_PKT_GEN_CTRL,
+			val, !(val & QCA8075_MMD7_PKT_GEN_INPROGR),
+			50000, 1000000,	true);
+	} else { /* off */
+		/* packet number */
+		phy_write_mmd(phy, 7, QCA8075_MMD7_PKT_GEN_PKT_NUMB, 0x0);
+		/* disable CRC checker and packet counter */
+		phy_write_mmd(phy, 7, QCA8075_MMD7_CRC_AND_PKTS_COUNT, 0x0);
+		/* disable traffic gen */
+		phy_write_mmd(phy, 7, QCA8075_MMD7_PKT_GEN_CTRL, 0x0);
+	}
+}
+
+static int qca8k_get_phy_pkt_gen_test_result(
+struct phy_device *phy, int pkts_num)
+{
+	u32 tx_ok, tx_error;
+	u32 rx_ok, rx_error;
+	u32 tx_ok_high16;
+	u32 rx_ok_high16;
+	u32 tx_all_ok, rx_all_ok;
+
+	/* check counter */
+	tx_ok = phy_read_mmd(phy, 7, QCA8075_MMD7_EG_FRAME_RECV_CNT_LO);
+	tx_ok_high16 = phy_read_mmd(phy, 7, QCA8075_MMD7_EG_FRAME_RECV_CNT_HI);
+	tx_error = phy_read_mmd(phy, 7, QCA8075_MMD7_EG_FRAME_ERR_CNT);
+	rx_ok = phy_read_mmd(phy, 7, QCA8075_MMD7_IG_FRAME_RECV_CNT_LO);
+	rx_ok_high16 = phy_read_mmd(phy, 7, QCA8075_MMD7_IG_FRAME_RECV_CNT_HI);
+	rx_error = phy_read_mmd(phy, 7, QCA8075_MMD7_IG_FRAME_ERR_CNT);
+	tx_all_ok = tx_ok + (tx_ok_high16 << 16);
+	rx_all_ok = rx_ok + (rx_ok_high16 << 16);
+
+	/* pr_info("*** phy: %d ***\n", phy->mdio.addr);
+	pr_info("tx_ok: %d, tx_error: %d\n", tx_all_ok, tx_error);
+	pr_info("rx_ok: %d, rx_error: %d\n", rx_all_ok, rx_error); */
+
+	if (tx_all_ok < pkts_num)
+		return -1;
+	if(rx_all_ok < pkts_num)
+		return -2;
+	if(tx_error)
+		return -3;
+	if(rx_error)
+		return -4;
+	return 0; /* test is ok */
+}
+
+static int qca8k_test_dsa_port_for_errors(struct qca8k_priv *priv,
+struct phy_device *phy, int port)
+{
+	int res;
+	const int test_pkts_num = 4096;
+
+	qca8k_phy_loopback_on_off(priv, phy, port, 1);
+	qca8k_switch_port_loopback_on_off(priv, port, 1);
+	qca8k_phy_pkt_gen_on_off(priv, phy, test_pkts_num, 1);
+
+	res = qca8k_get_phy_pkt_gen_test_result(phy, test_pkts_num);
+
+	qca8k_phy_pkt_gen_on_off(priv, phy, test_pkts_num, 0);
+	qca8k_switch_port_loopback_on_off(priv, port, 0);
+	qca8k_phy_loopback_on_off(priv, phy, port, 0);
+	return res;
+}
+
+static int qca8k_do_dsa_sw_ports_self_test(struct qca8k_priv *priv)
+{
+	struct device_node *dn = priv->dev->of_node;
+	struct device_node *ports, *port;
+	struct device_node *phy_dn;
+	struct phy_device *phydev;
+	int reg, err = 0;
+
+	ports = of_get_child_by_name(dn, "ports");
+	if (!ports) {
+		dev_err(priv->dev, "no ports child node found\n");
+			return -EINVAL;
+	}
+
+	for_each_available_child_of_node(ports, port) {
+		err = of_property_read_u32(port, "reg", &reg);
+		if (err)
+			goto out_put_node;
+		if (reg >= QCA8K_NUM_PORTS) {
+			err = -EINVAL;
+			goto out_put_node;
+		}
+		phy_dn = of_parse_phandle(port, "phy-handle", 0);
+		if (phy_dn) {
+			phydev = of_phy_find_device(phy_dn);
+			if (phydev) {
+				int result;
+				result = qca8k_test_dsa_port_for_errors(priv, phydev, reg);
+				put_device(&phydev->mdio.dev);
+				if (result) {
+					err = -EFAULT;
+					goto out_put_node;
+				}
+			}
+			of_node_put(phy_dn);
+		}
+	}
+
+out_put_node:
+	of_node_put(ports);
+	qca8k_fdb_flush(priv);
+	return err;
+}
+
+static int psgmii_vco_calibrate_and_test(struct dsa_switch *ds)
+{
+	int ret, a, test_result;
+	struct qca8k_priv *priv = ds->priv;
+
+	for (a = 0; a <= QCA8K_PSGMII_CALB_NUM; a++) {
+		ret = psgmii_vco_calibrate(priv, 100);
+		if (ret)
+			return ret;
+		test_result = qca8k_do_dsa_sw_ports_self_test(priv);
+		if (!test_result) {
+			if (a > 0) {
+				dev_warn(priv->dev,	"PSGMII work was stabilized after %d "
+					"calibration retries !\n", a);
+			}
+			return 0;
+		} else {
+			schedule();
+			if (a > 0 && a % 10 == 0) {
+				ipq_psgmii_do_reset(priv, 100);
+				set_current_state(TASK_INTERRUPTIBLE);
+				schedule_timeout(msecs_to_jiffies(a * 100));
+			}
+		}
+	}
+
+	dev_err(priv->dev,	"PSGMII work is unstable !!! "
+		"Repeated recalibration attempts did not help !\n");
+	return test_result;
+}
+
 static int ipq4019_psgmii_configure(struct dsa_switch *ds)
 {
 	struct qca8k_priv *priv = ds->priv;
 	int ret;
 
 	if (!priv->psgmii_calibrated) {
-		ret = psgmii_vco_calibrate(ds);
+		ret = psgmii_vco_calibrate_and_test(ds);
 
 		ret = regmap_clear_bits(priv->psgmii, PSGMIIPHY_MODE_CONTROL,
 					PSGMIIPHY_MODE_ATHR_CSCO_MODE_25M);
diff -rNu a/drivers/net/dsa/qca/qca8k-ipq4019.h b/drivers/net/dsa/qca/qca8k-ipq4019.h
--- a/drivers/net/dsa/qca/qca8k-ipq4019.h	2022-04-11 11:01:21.796045947 +0300
+++ b/drivers/net/dsa/qca/qca8k-ipq4019.h	2022-04-14 10:02:54.657752425 +0300
@@ -150,6 +150,7 @@
 #define   QCA8K_PORT_LOOKUP_STATE_FORWARD		(4 << 16)
 #define   QCA8K_PORT_LOOKUP_STATE			GENMASK(18, 16)
 #define   QCA8K_PORT_LOOKUP_LEARN			BIT(20)
+#define   QCA8K_PORT_LOOKUP_LOOPBACK	BIT(21)
 
 #define QCA8K_REG_GLOBAL_FC_THRESH			0x800
 #define   QCA8K_GLOBAL_FC_GOL_XON_THRES(x)		((x) << 16)
@@ -206,6 +207,24 @@
 #define PSGMIIPHY_VCO_CALIBRATION_CONTROL_REGISTER_2	0xa0
 #define   PSGMIIPHY_REG_PLL_VCO_CALIB_READY		BIT(0)
 
+#define   MII_QCA8075_SSTATUS								0x11
+#define   QCA8075_PHY_SPEC_STATUS_LINK			BIT(10)
+#define   QCA8075_MMD7_CRC_AND_PKTS_COUNT		0x8029
+#define   QCA8075_MMD7_PKT_GEN_PKT_NUMB			0x8021
+#define   QCA8075_MMD7_PKT_GEN_PKT_SIZE			0x8062
+#define   QCA8075_MMD7_PKT_GEN_CTRL					0x8020
+#define   QCA8075_MMD7_CNT_SELFCLR					BIT(1)
+#define   QCA8075_MMD7_CNT_FRAME_CHK_EN			BIT(0)
+#define   QCA8075_MMD7_PKT_GEN_START				BIT(13)
+#define   QCA8075_MMD7_PKT_GEN_INPROGR			BIT(15)
+#define   QCA8075_MMD7_IG_FRAME_RECV_CNT_HI	0x802a
+#define   QCA8075_MMD7_IG_FRAME_RECV_CNT_LO	0x802b
+#define   QCA8075_MMD7_IG_FRAME_ERR_CNT			0x802c
+#define   QCA8075_MMD7_EG_FRAME_RECV_CNT_HI	0x802d
+#define   QCA8075_MMD7_EG_FRAME_RECV_CNT_LO	0x802e
+#define   QCA8075_MMD7_EG_FRAME_ERR_CNT			0x802f
+#define   QCA8K_PSGMII_CALB_NUM							100
+
 enum {
 	QCA8K_PORT_SPEED_10M = 0,
 	QCA8K_PORT_SPEED_100M = 1,
